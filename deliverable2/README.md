# Deliverable #2

## Introduction

This document is our written simulation test report. We will submit a separate paper to the IEEE Test AI conference as suggested by the IEEE Test AI Challenge organizers. A copy of that paper is available in this repo for completeness.

In this document, we briefly describe SALVO (Stephan, ALessio and VuOng, our names, but also the Italian word for "safe") for generating interesting and diversified tests from existing maps automatically.

The scripts to generate, filter, and execute the test cases are available in this repo under the folder `scripts`. 
**TODO: check this is the right folder!!**
However, we do not provide any predefined scenarios, trips or routes, as those are automatically derived at runtime by SALVO. Instead, we report examples of generated trips/routes under the folder `trips-routes`. The visualization of the trips correspond to the output of the sample usage commands listed below.
**TODO: check this is the right folder!!**

Simulation execution reports for the selected scenario executions are reported in folder `simulation reports`. 
**TODO: check this is the right folder!!**
We report only a few examples of the driving scenarios generated by SALVO, including scenarios that take place at intersection and involved static obstacles/NPC. 

Links to the videos illustrating SALVO in actions are listed below.
**TODO: Add more videos and descriptions!!**

## SALVO: Automated Generation of Diversified Tests for Self-driving Cars from Existing Maps

This section describes our approach, the generated test scenarios, simulation test coverage, and problem findings.

SALVO starts from the consideration that manually generated HD maps are very expensive; therefore, they must be used (and re-used) wisely and extensively. Consequently, SALVO leverage existing maps to generate as many tests as possible. 

Generating many tests without guidance, however, is not what SALVO does. Instead, it follows a systematic approach to maximize the diversity of the generated tests in each map while generating relevant driving scenarios. We define relevant driving scenarios those scenarios that require the ego-car to drive across an intersection.

### SALVO in a Nutshell

SALVO works as follows in steps: given a map in OpenDrive (.xodr) format, (1) SALVO identifies all the intersections in the map and (2) generates all legal trajectories that cross them; each of those trajectories implements a driving scenario. Next, (3) SALVO selects trajectories that are quantifiably different from one another and (4) generates test cases implementing them. As an extension, (5) we also allow SALVO to place static obstacles in front of the ego-car to study the ego-car in even more driving scenarios.

#### 1. Identifying Intersections

Given the input map in the OpenDrive format, we use the opendrive2lanelet library [1] to transform it into the more abstract and less vendor-specific lanelets format. This format provides a straightforward organization of the various lanelets in the map using formal relations such as `follows` and `is_adjacent` but does not natively identify intersections. Therefore, SALVO implements an heuristic to identify them. First, it uses geometrical information about each lanelet to identify overlapping lanelets. Next, it group together lanelets that overlap

TODO



#### 2. Generating Relevant Scenarios 

Relevant scenarios are defined by legal trajectories across intersections.
They start on a given lane before an intersection, continue on the same lane across the intersection, and end always on the (logically) same lane after the intersection. The distances before and after the intersections are input parameters and let testers indirectly define how long the tests will last. 
Notably, because intersections have different configuration and geometry those trajectory force the ego-car to turn left, turn right, or go straight.

#### 3. Selecting Diversified Scenarios

Up to this point, SALVO did not care about diversity of test cases, as it simply discovered all the possible legal trajectories in a map. It does so to explore as much as possible the possibility offered by the input map. However, many trajectory may stress the ego-car in the same way. For example, the CubeTown map contains two intersections that are one the exact copy of the other. Testing the ego-car on both intersections instead of only one is not likely to provide any additional insight on its behavior, therefore, SALVO uses a greedy heuristic to filter out test cases that are too similar to each other. The goal is improving the cost and diversity of the resulting test suites.

We study two approaches for filtering out similar test cases, both based on the analysis of the trajectory that supposedly the ego-car follows during the test execution. The first approach consists of computing the Iterative Levenshtein distance between each pair of legal trajectories and filtering out the trajectories distance falls below a configurable threshold. The smaller is the threshold value, the larger is the resulting test suites. The 

#### 4. Generating Test Cases

#### 5. Placing Obstacles 

## Requirements
SALVO is implemented as a Python command line application. It requires Python version 3.7 and the libraries listed in the `requirements.txt` file. 
**TODO CHECK THAT ALL THE PACKAGES AND VERSIONS ARE LISTED HERE**

We tested SALVO on Ubuntu **TODO Add the versions of the OS** running the SVL Simulator version 2021.01 and Apollo 6.0. We used only the SVL Python interface and the following maps:

- Cube Town
- Borregas Avenue
- Shalun
- GoMentum
- San Francisco

**Note:** SALVO requires the .xodr files of the maps, so for simplify we copied those files inside this repo.

**TODO: Add specifications for the ego-car, cyber-bridge, etc.**

## Usage Examples

The following scripts exemplify how to invoke SALVO. The all assume you correctly installed the requirements (and activated the virtual environment).
The visualizations of the trips generated by those command can be found inside the folder `trips-routes`.

This command generates **all** the paths across the intersections that SALVO finds in the given `map-file`. Each path starts a configurable number of meters before the intersection (`before-junction`), crosses the intersection (going straight, turning left or right), and ends a configurable number of meters after it (`after_junction`).
**TODO: Check if parameters are map_file or map-file, usually the format uses the hyphen (-) not the underscore (_)**
In the sample command, we configure SALVO to use the Cube Town map and to start/end paths 20 meters before/after the intersection. Since there are two intersections in the map, each having three incoming roads and two possible directions, this command should generate 12 paths.
 
```
python salvo.py generate-all-paths \
        --map_file CubeTown \
        --before_junction 20 \
        --after_junction 20
```

The following two commands, instead, configure SALVO to filter the generated paths to achieve diversity. The first command uses a greedy heuristic to filter paths that are too similar to each other. The path similarity is computed using the Iterative Levenshtein distance of the (supposed) trajectory of the ego car. Setting a value of 1.9 for the distance, should lead to selecting 8 out of 12 paths.

```
python salvo.py generate-all-paths \
        --map_file CubeTown \
        --before_junction 20 \
        --after_junction 20 \
        --filter distance 1.9 True
```

The second command instead uses the feature maps defined in [2] to characterize the generated paths and filters those paths that cover the same cells of the feature map. In the example command, we configure the map to have 10 cells per feature (for a total of 100 cells in the map). Using this configuration for the CubeTown map, SALVO should produce 5 paths.

```
python salvo.py generate-all-paths \
        --map_file CubeTown \
        --before_junction 20 \
        --after_junction 20 \
        --filter feature 10 True
```

The previous three commands configure SALVO to generate test cases that do not involve any NPC. We allows NPC acting as static obstacles with the following command:

```
python salvo.py generate-all-paths-with-parking \
        --map_file BorregasAve \
        --before_junction 20 \
        --after_junction 20 \
        --parking_distance 5
```
In this example, we configure SALVO to use the Borregas Avenue map, start and end paths at 20 meters from the intersection and placing obstacles at 5 meters from the ego car. Note: In this first implementation of our approach, we do not place NPC after the intersections.

**TODO Check that 5 meters are from the ego car or the intersection... no idea... **


Finally, we enable SALVO to generate test cases that are different in the trajectory and in the presence of static obstacles with the following commands that combine the previous ones:

```
python salvo.py generate-all-paths-with-parking --map_file BorregasAve --before_junction 20 --after_junction 20 --parking_distance 5 --filter distance 1.9 False

python salvo.py generate-all-paths-with-parking --map_file BorregasAve --before_junction 20 --after_junction 20 --parking_distance 5 --filter feature 10 False
```

## Link to Videos
We published several video on YouTube illustrating our approach in action against Apollo Baidu (v.6.0).
**TODO: Check that the version of APOLLO is correct **
In this section, we link those videos and provide a short description of their content.

**TODO: Probably we should add some more videos here!! **
**TODO: Double check that the videos are working fine **

 - [Static Obstacles in CubeTown](https://youtu.be/WLIh9Pv8FcI). This video shows how SALVO created four tests in the CubeTown map to cover various combinations of static object placement: no obstacle, an obstacle in the middle of the lane, and obstacles partially occluding the lane on the left and right sides.

## References
[1] M. Althoff et al., "Automatic Conversion of Road Networks from OpenDRIVE to Lanelets," in Proc. of the IEEE International Conference on Service Operations and Logistics, and Informatics, 2018
[2] T. Zohdinasab et al., "DeepHyperion: exploring the feature space of deep learning-based systems through illumination search," in Proc. of ACM SIGSOFT International Symposium on Software Testing and Analysis, 2021
